use crate::ConcurrentHashMap;
use core::borrow::Borrow;
use core::fmt::{self, Debug, Formatter};
use core::hash::{BuildHasher, Hash};
use core::ops::{Deref, Index};
use crossbeam_epoch::Guard;

#[cfg(feature = "std")]
/// A reference to a [`HashMap`], constructed with [`HashMap::pin`] or [`HashMap::with_guard`].
///
/// The current thread will be pinned for the duration of this reference.
/// Keep in mind that this prevents the collection of garbage generated by the map.
pub type HashMapRef<'map, K, V, S = crate::DefaultHashBuilder> =
    ConcurrentHashMapRef<'map, K, V, parking_lot::RawMutex, S>;

/// A reference to a [`ConcurrentHashMap`], constructed with [`HashMap::pin`] or [`HashMap::with_guard`].
///
/// Prefer the type alias [`HashMapRef`].
///
/// The current thread will be pinned for the duration of this reference.
/// Keep in mind that this prevents the collection of garbage generated by the map.
pub struct ConcurrentHashMapRef<'map, K: 'static, V: 'static, L, S = crate::DefaultHashBuilder>
where
    L: lock_api::RawMutex,
    S: BuildHasher,
{
    // NOTE: below struct must be identical
    map: &'map ConcurrentHashMap<K, V, L, S>,
    guard: GuardRef<'map>,
}

enum GuardRef<'g> {
    Owned(Guard),
    Ref(&'g Guard),
}

impl Deref for GuardRef<'_> {
    type Target = Guard;

    #[inline]
    fn deref(&self) -> &Guard {
        match *self {
            GuardRef::Owned(ref guard) | GuardRef::Ref(&ref guard) => guard,
        }
    }
}

impl<K, V, L, S> ConcurrentHashMap<K, V, L, S>
where
    K: Sync + Send + Clone + Hash + Eq,
    V: Sync + Send,
    S: BuildHasher,
    L: lock_api::RawMutex,
{
    /// Get a reference to this map with the current thread pinned.
    ///
    /// Keep in mind that for as long as you hold onto this, you are preventing the collection of
    /// garbage generated by the map.
    pub fn pin(&self) -> ConcurrentHashMapRef<'_, K, V, L, S> {
        ConcurrentHashMapRef {
            guard: GuardRef::Owned(self.guard()),
            map: &self,
        }
    }

    /// Get a reference to this map with the given guard.
    pub fn with_guard<'g>(&'g self, guard: &'g Guard) -> ConcurrentHashMapRef<'g, K, V, L, S> {
        ConcurrentHashMapRef {
            map: &self,
            guard: GuardRef::Ref(guard),
        }
    }
}

impl<K, V, L, S> ConcurrentHashMapRef<'_, K, V, L, S>
where
    K: Sync + Send + Clone + Hash + Eq,
    V: Sync + Send,
    S: BuildHasher,
    L: lock_api::RawMutex,
{
    /// Tests if `key` is a key in this table.
    /// See also [`HashMap::contains_key`].
    pub fn contains_key<Q>(&self, key: &Q) -> bool
    where
        K: Borrow<Q>,
        Q: ?Sized + Hash + Eq,
    {
        self.map.contains_key(key, &self.guard)
    }

    /// Returns the value to which `key` is mapped.
    /// See also [`HashMap::get`].
    pub fn get<'g, Q>(&'g self, key: &Q) -> Option<&'g V>
    where
        K: Borrow<Q>,
        Q: ?Sized + Hash + Eq,
    {
        self.map.get(key, &self.guard)
    }

    /// Returns the key-value pair corresponding to `key`.
    /// See also [`HashMap::get_key_value`].
    pub fn get_key_value<'g, Q>(&'g self, key: &Q) -> Option<(&'g K, &'g V)>
    where
        K: Borrow<Q>,
        Q: ?Sized + Hash + Eq,
    {
        self.map.get_key_value(key, &self.guard)
    }

    /// Maps `key` to `value` in this table.
    /// See also [`HashMap::insert`].
    pub fn insert(&self, key: K, value: V) -> Option<&'_ V> {
        self.map.insert(key, value, &self.guard)
    }

    /// Removes all entries from this map.
    /// See also [`HashMap::clear`].
    pub fn clear(&self) {
        self.map.clear(&self.guard);
    }

    /// If the value for the specified `key` is present, attempts to
    /// compute a new mapping given the key and its current mapped value.
    /// See also [`HashMap::compute_if_present`].
    pub fn compute_if_present<'g, Q, F>(&'g self, key: &Q, remapping_function: F) -> Option<&'g V>
    where
        K: Borrow<Q>,
        Q: ?Sized + Hash + Eq,
        F: FnOnce(&K, &V) -> Option<V>,
    {
        self.map
            .compute_if_present(key, remapping_function, &self.guard)
    }

    /// Tries to reserve capacity for at least additional more elements.
    /// See also [`HashMap::reserve`].
    pub fn reserve(&self, additional: usize) {
        self.map.reserve(additional, &self.guard)
    }

    /// Removes the key (and its corresponding value) from this map.
    /// See also [`HashMap::remove`].
    pub fn remove<'g, Q>(&'g self, key: &Q) -> Option<&'g V>
    where
        K: Borrow<Q>,
        Q: ?Sized + Hash + Eq,
    {
        self.map.remove(key, &self.guard)
    }

    /// Retains only the elements specified by the predicate.
    /// See also [`HashMap::retain`].
    pub fn retain<F>(&self, f: F)
    where
        F: FnMut(&K, &V) -> bool,
    {
        self.map.retain(f, &self.guard);
    }

    /// Retains only the elements specified by the predicate.
    /// See also [`HashMap::retain_force`].
    pub fn retain_force<F>(&self, f: F)
    where
        F: FnMut(&K, &V) -> bool,
    {
        self.map.retain_force(f, &self.guard);
    }

    /// An iterator visiting all key-value pairs in arbitrary order.
    /// The iterator element type is `(&'g K, &'g V)`.
    /// See also [`HashMap::iter`].
    pub fn iter(&self) -> impl Iterator<Item = (&K, &V)> {
        self.map.iter(&self.guard)
    }

    /// An iterator visiting all keys in arbitrary order.
    /// The iterator element type is `&'g K`.
    /// See also [`HashMap::keys`].
    pub fn keys(&self) -> impl Iterator<Item = &K> {
        self.map.keys(&self.guard)
    }

    /// An iterator visiting all values in arbitrary order.
    /// The iterator element type is `&'g V`.
    /// See also [`HashMap::values`].
    pub fn values(&self) -> impl Iterator<Item = &V> {
        self.map.values(&self.guard)
    }

    /// Returns the number of entries in the map.
    /// See also [`HashMap::len`].
    pub fn len(&self) -> usize {
        self.map.len()
    }

    /// Returns `true` if the map is empty. Otherwise returns `false`.
    /// See also [`HashMap::is_empty`].
    pub fn is_empty(&self) -> bool {
        self.map.is_empty()
    }
}

impl<K, V, L, S> Debug for ConcurrentHashMapRef<'_, K, V, L, S>
where
    K: Sync + Send + Clone + Hash + Eq + Debug,
    V: Sync + Send + Debug,
    S: BuildHasher,
    L: lock_api::RawMutex,
{
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        f.debug_map().entries(self.iter()).finish()
    }
}

#[cfg(feature = "std")]
impl<K, V, L, S> Clone for ConcurrentHashMapRef<'_, K, V, L, S>
where
    K: Sync + Send + Clone + Hash + Eq,
    V: Sync + Send,
    S: BuildHasher,
    L: lock_api::RawMutex,
{
    fn clone(&self) -> Self {
        self.map.pin()
    }
}

impl<K, V, L, S> PartialEq for ConcurrentHashMapRef<'_, K, V, L, S>
where
    K: Sync + Send + Clone + Hash + Eq,
    V: Sync + Send + PartialEq,
    S: BuildHasher,
    L: lock_api::RawMutex,
{
    fn eq(&self, other: &Self) -> bool {
        self.map.guarded_eq(&other.map, &self.guard, &other.guard)
    }
}

impl<K, V, L, S> PartialEq<ConcurrentHashMap<K, V, L, S>> for ConcurrentHashMapRef<'_, K, V, L, S>
where
    K: Sync + Send + Clone + Hash + Eq,
    V: Sync + Send + PartialEq,
    S: BuildHasher,
    L: lock_api::RawMutex,
{
    fn eq(&self, other: &ConcurrentHashMap<K, V, L, S>) -> bool {
        self.map.guarded_eq(&other, &self.guard, &other.guard())
    }
}

impl<K, V, L, S> PartialEq<ConcurrentHashMapRef<'_, K, V, L, S>> for ConcurrentHashMap<K, V, L, S>
where
    K: Sync + Send + Clone + Hash + Eq,
    V: Sync + Send + PartialEq,
    S: BuildHasher,
    L: lock_api::RawMutex,
{
    fn eq(&self, other: &ConcurrentHashMapRef<'_, K, V, L, S>) -> bool {
        self.guarded_eq(&other.map, &self.guard(), &other.guard)
    }
}

impl<K, V, L, S> Eq for ConcurrentHashMapRef<'_, K, V, L, S>
where
    K: Sync + Send + Clone + Hash + Eq,
    V: Sync + Send + Eq,
    S: BuildHasher,
    L: lock_api::RawMutex,
{
}

impl<K, Q, V, L, S> Index<&'_ Q> for ConcurrentHashMapRef<'_, K, V, L, S>
where
    K: Sync + Send + Clone + Hash + Eq + Borrow<Q>,
    Q: ?Sized + Hash + Eq,
    V: Sync + Send,
    S: BuildHasher,
    L: lock_api::RawMutex,
{
    type Output = V;

    fn index(&self, key: &Q) -> &V {
        self.get(key).expect("no entry found for key")
    }
}
